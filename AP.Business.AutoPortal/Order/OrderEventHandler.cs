// ==============================================================================================================
// Microsoft patterns & practices
// CQRS Journey project
// ==============================================================================================================
// ©2012 Microsoft. All rights reserved. Certain content used with permission from contributors
// http://go.microsoft.com/fwlink/p/?LinkID=258575
// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance 
// with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software distributed under the License is 
// distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
// See the License for the specific language governing permissions and limitations under the License.
// ==============================================================================================================

namespace AP.Business.AutoPortal.Order
{
    using System;
    using System.Linq;
    using System.Linq.Expressions;
    using Infrastructure.Messaging.Handling;
    using AP.Business.Model.Registration.Events;
    using AP.Repository.Context;
    using Microsoft.EntityFrameworkCore;
    using AP.EntityModel.Booking;
    using Microsoft.Extensions.Logging;
    using EntityFramework.DbContextScope.Interfaces;
    using AP.Core.Database;

    // This denormalized version of an order is being created in the Conference Management BC, via events
    // coming from the Registration BC (generated by event sourced aggregates).
    // ALL the information is there to generate this denormalized version, but nevertheless, the events
    // seem too granular to keep up with, considering this is a different and isolated bounded context.

    // We feel that reusing the same events that the Registration BC uses internally (for both event sourcing
    // in the write-model, and generating projections for the read model) for integrating between different
    // BCs starts to make the 2 BCs very coupled (regardless of that coupling being through messaging).

    // An alternative is that the Registration BC can create a denormalization like this one on "the other side",
    // and at one point in time publish an event specifically made for integration, with a full dump
    // of the order information.
    // A slightly different alternative, is that we generate the projection on the other side, and publish
    // an event notifying the listeners that a new order is ready, so they (the Conference Mgmt BC)
    // can (asynchronously) make a direct service call and get the information for the order
    // (still getting the fully denormalized order in a single service call).

    // The advisors agreed that handling this many events is OK nevertheless.
    public class OrderEventHandler : AmbientContext<WorkshopContext>,
        IEventHandler<OrderPlaced>,
        IEventHandler<OrderRegistrantAssigned>,
        IEventHandler<OrderTotalsCalculated>,
        IEventHandler<OrderConfirmed>,
        IEventHandler<OrderExpired>,
        IEventHandler<AnchorAssignmentsCreated>,
        IEventHandler<AnchorAssigned>,
        IEventHandler<AnchorAssignmentUpdated>,
        IEventHandler<AnchorUnassigned>
    {
        private readonly IDbContextScopeFactory contextFactory;
        private readonly ILogger<OrderEventHandler> logger;

        public OrderEventHandler(IDbContextScopeFactory contextFactory, IAmbientDbContextLocator locator, ILogger<OrderEventHandler> logger)
            : base(locator)
        {
            this.contextFactory = contextFactory;
            this.logger = logger;
        }

        public void Handle(OrderPlaced @event)
        {
            using (var context = this.contextFactory.Create())
            {
                DbContext.Orders.Add(new Order(@event.WorkshopId, @event.SourceId, @event.AccessCode));
                context.SaveChanges();
            }
        }

        public void Handle(OrderRegistrantAssigned @event)
        {
            ProcessOrder(order => order.Id == @event.SourceId, order =>
            {
                order.RegistrantEmail = @event.Email;
                order.RegistrantName = @event.LastName; //+ ", " + @event.FirstName;
            });
        }

        public void Handle(OrderTotalsCalculated @event)
        {
            if (!ProcessOrder(order => order.Id == @event.SourceId, order => order.TotalAmount = @event.Total))
            {
                logger.LogError("Failed to locate the order with id {0} to apply calculated totals", @event.SourceId);
            }
        }

        public void Handle(OrderConfirmed @event)
        {
            if (!ProcessOrder(order => order.Id == @event.SourceId, order => order.Status = Order.OrderStatus.Paid))
            {
                logger.LogError("Failed to locate the order with {0} to apply confirmed payment.", @event.SourceId);
            }
        }

        public void Handle(OrderExpired @event)
        {
            using (var context = this.contextFactory.Create())
            {
                var order = DbContext.Orders.FirstOrDefault(x => x.Id == @event.SourceId);
                if (order != null)
                {
                    DbContext.Orders.Remove(order);
                    context.SaveChanges();
                }
            }
        }

        public void Handle(AnchorAssignmentsCreated @event)
        {
            if (!ProcessOrder(order => order.Id == @event.OrderId, order => order.AssignmentsId = @event.SourceId))
            {
                logger.LogError("Failed to locate the order with {0} for the seat assignments being created with id {1}.", @event.OrderId, @event.SourceId);
            }
        }

        public void Handle(AnchorAssigned @event)
        {
            if (!ProcessOrder(order => order.AssignmentsId == @event.SourceId, order =>
            {
                var seat = order.Anchors.FirstOrDefault(x => x.Position == @event.Position);
                if (seat != null)
                {
                    seat.Attendee_FirstName = @event.Attendee.FirstName;
                    seat.Attendee_LastName = @event.Attendee.LastName;
                    seat.Attendee_Email = @event.Attendee.Email;
                }
                else
                {
                    order.Anchors.Add(new OrderAnchor(@event.SourceId,
                        @event.Position, @event.SeatType)
                    {
                        Attendee_FirstName = @event.Attendee.FirstName,
                        Attendee_LastName = @event.Attendee.LastName,
                        Attendee_Email = @event.Attendee.Email
                    });
                }
            }))
            {
                logger.LogError("Failed to locate the order with seat assignments id {0} for the seat assignment being assigned at position {1}.", @event.SourceId, @event.Position);
            }
        }

        public void Handle(AnchorAssignmentUpdated @event)
        {
            if (!ProcessOrder(order => order.AssignmentsId == @event.SourceId, order =>
            {
                var seat = order.Anchors.FirstOrDefault(x => x.Position == @event.Position);
                if (seat != null)
                {
                    seat.Attendee_FirstName = @event.Attendee.FirstName;
                    seat.Attendee_LastName = @event.Attendee.LastName;
                }
                else
                {
                    logger.LogError("Failed to locate the seat being updated at position {0} for assignment {1}.", @event.Position, @event.SourceId);
                }
            }))
            {
                logger.LogError("Failed to locate the order with seat assignments id {0} for the seat assignment being updated at position {1}.", @event.SourceId, @event.Position);
            }
        }

        public void Handle(AnchorUnassigned @event)
        {
            if (!ProcessOrder(order => order.AssignmentsId == @event.SourceId, order =>
            {
                var seat = order.Anchors.FirstOrDefault(x => x.Position == @event.Position);
                if (seat != null)
                {
                    order.Anchors.Remove(seat);
                }
                else
                {
                    logger.LogError("Failed to locate the seat being unassigned at position {0} for assignment {1}.", @event.Position, @event.SourceId);
                }
            }))
            {
                logger.LogError("Failed to locate the order with seat assignments id {0} for the seat being unassigned at position {1}.", @event.SourceId, @event.Position);
            }
        }

        private bool ProcessOrder(Expression<Func<Order, bool>> lookup, Action<Order> orderAction)
        {
            using (var context = this.contextFactory.Create())
            {
                var order = DbContext.Orders.Include(x => x.Anchors).FirstOrDefault(lookup);
                if (order != null)
                {
                    orderAction.Invoke(order);
                    context.SaveChanges();
                    return true;
                }
                else
                {
                    return false;
                }
            }
        }
    }
}
